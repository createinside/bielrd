<?php

/**
 * @file
 * Main module file.
 */

/**
 * Implements hook_menu().
 */
function rebild_revisions_delete_menu() {
  $items['admin/config/system/rebild_revisions_delete_settings'] = array(
    'title' => 'Revisions delete',
    'description' => 'Administer revisions deletion',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rebild_revisions_delete_settings_form'),
    'access arguments' => array('administer rebild_revisions_delete'),
  );

  return $items;
}

/**
 * Implements hook_cron().
 */
function rebild_revisions_delete_cron() {
  $run_delete = variable_get('rebild_revisions_delete_cron_active');

  if ($run_delete === 1) {
    rebild_revisions_delete_run(FALSE);
  }
}

/**
 * Run delete action by batch.
 */
function rebild_revisions_delete_run_batch() {
  rebild_revisions_delete_run(TRUE);
}

/**
 * Delete old revisions action.
 *
 * @param bool $run_as_batch
 *   If set true - deletes by running batch.
 */
function rebild_revisions_delete_run($run_as_batch = FALSE) {

  if ($run_as_batch) {
    $batch = array(
      'operations' => array(),
      'title' => t('Deleting old revisions'),
      'finished' => 'rebild_revisions_delete_batch_callback',
    );
  }

  $node_types = node_type_get_types();
  if (!empty($node_types)) {
    foreach ($node_types as $node_type) {
      $node_type_config = variable_get('rebild_revisions_delete_node_type-' . $node_type->type);

      if ($node_type_config['active'] === 1) {

        $timestamp_older_than_days_back_limit = strtotime('-' . $node_type_config['older_than_days_back_limit'] . 'days');
        $revisions_by_nodeid = rebild_revisions_delete_get_revisions_by_node_type($node_type->type);

        foreach ($revisions_by_nodeid as $nid => $revisions) {
          // Get timestamp of current published revision.
          $current_published_timestamp = FALSE;
          foreach ($revisions as $revision) {
            if ($revision->node_current_published_vid == $revision->vid) {
              $current_published_timestamp = $revision->timestamp;
              break;
            }
          }
          if (!$current_published_timestamp) {
            continue;
          }

          $revisions_amount = count($revisions);
          if ($revisions_amount > $node_type_config['minimum_revisions_to_keep']) {

            $revisions_amount_possible_delete = $revisions_amount - $node_type_config['minimum_revisions_to_keep'];
            $revisions_possible_delete = array_slice($revisions, 0, $revisions_amount_possible_delete);

            foreach ($revisions_possible_delete as $revision) {

              // Only revisions older than current published can be deleted.
              if ($revision->timestamp < $current_published_timestamp) {
                // Only revisions older than time limit can be deleted.
                if ($revision->timestamp < $timestamp_older_than_days_back_limit) {
                  if ($run_as_batch) {
                    $batch['operations'][] = array(
                      'rebild_revisions_delete_revision_delete',
                      array($revision),
                    );
                  }
                  else {
                    rebild_revisions_delete_revision_delete($revision);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  rebild_revisions_delete_clean_workbench_moderation_history();

  if ($run_as_batch && count($batch['operations']) > 0) {
    batch_set($batch);
  }
}

/**
 * Batch callback if rebild_revisions_delete_run() is run as batch.
 */
function rebild_revisions_delete_batch_callback() {
  drupal_set_message(t('Batch run success!'));
}

/**
 * Clean autogenerated workbench moderation's unnecessary.
 */
function rebild_revisions_delete_clean_workbench_moderation_history() {
  db_delete('workbench_moderation_node_history')
    ->condition('from_state', 'draft')
    ->condition('state', 'draft')
    ->condition('uid', '0')
    ->condition('is_current', '0')
    ->execute();
}

/**
 * Deletes the revision.
 *
 * @param object $revision
 *   Revision object.
 */
function rebild_revisions_delete_revision_delete($revision) {
  $revision_deleted = node_revision_delete($revision->vid);

  if ($revision_deleted === TRUE) {
    db_delete('workbench_moderation_node_history')
      ->condition('nid', $revision->nid)
      ->condition('vid', $revision->vid)
      ->condition('is_current', '0', '=')
      ->execute();
  }
}

/**
 * Gets revisions for all nodes of a given type.
 *
 * @param string $type
 *   The node type.
 *
 * @return array
 *   Multidimensional array containing revisions with nid as key.
 */
function rebild_revisions_delete_get_revisions_by_node_type($type) {

  $revisions_by_node = array();

  $query = db_select('node_revision', 'nr');
  $query->join('node', 'n', 'nr.nid = n.nid');
  $query->fields('n', array('type'));
  $query->addField('n', 'vid', 'node_current_published_vid');
  $query->fields('nr', array('nid', 'vid', 'timestamp', 'title'));
  $query->condition('n.type', $type);
  $revisions = $query->execute()->fetchAll();
  if (!empty($revisions)) {
    usort($revisions, 'rebild_revisions_delete_sort_revisions_by_timestamp_cmp');

    foreach ($revisions as $revision) {
      $revisions_by_node[$revision->nid][] = $revision;
    }
  }
  return $revisions_by_node;
}

/**
 * Sorts revisions by timestamp.
 */
function rebild_revisions_delete_sort_revisions_by_timestamp_cmp($a, $b) {
  if ($a->timestamp == $b->timestamp) {
    return 0;
  }
  return ($a->timestamp < $b->timestamp) ? -1 : 1;
}

module_load_include("inc", "rebild_revisions_delete", "rebild_revisions_delete.admin");
